package main

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/kenkyu392/go-holidays"
	"golang.org/x/text/language"
)

const (
	url          = "https://kenkyu392.github.io/holidays-jp/v1/time.json"
	appName      = "gen_jp_code"
	codeDirName  = "jp"
	codeFileName = "jp.gen.go"
	tmpl         = `// Code generated by go-holidays. DO NOT EDIT.
// Last Modified on %s
package jp
import (
	"time"
	"github.com/kenkyu392/go-holidays"
	"golang.org/x/text/language"
)
// Holidays in Japan
// %s ~ %s
var Holidays = holidays.Holidays{
	%s
}

// SubstituteHolidays in Japan
var SubstituteHolidays = holidays.Holidays{
	%s
}
`
	codeBlockTmpl = `{
		Time: time.Date(%d, %d, %d, 0, 0, 0, 0, JST),
		I18n: map[language.Tag]string{
			language.Japanese: "%s",
			language.English: "%s",
		},
		Tag: language.Japanese,
	},`
)

type Payload struct {
	Holidays []*Holiday `json:"holidays"`
}

type Holiday struct {
	Date time.Time         `json:"date"`
	I18n map[string]string `json:"i18n"`
}

func main() {
	log.SetPrefix(appName + " ")

	outPath, err := filePath(codeDirName, codeFileName)
	if err != nil {
		log.Fatal(err)
	}

	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	raw, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	lastModified, err := time.Parse(http.TimeFormat, resp.Header.Get("Last-Modified"))
	if err != nil {
		lastModified = time.Now()
	}

	payload := struct {
		Holidays []*struct {
			Date time.Time         `json:"date"`
			I18n map[string]string `json:"i18n"`
		} `json:"holidays"`
	}{}
	if json.Unmarshal(raw, &payload); err != nil {
		log.Fatal(err)
	}

	hs := make(holidays.Holidays, 0)
	for _, h := range payload.Holidays {
		hs = append(hs, &holidays.Holiday{
			Time: h.Date,
			I18n: map[language.Tag]string{
				language.Japanese: h.I18n["ja-JP"],
				language.English:  h.I18n["en-US"],
			},
			Tag: language.Japanese,
		})
	}

	code := genCode(hs, lastModified)
	if err := ioutil.WriteFile(outPath, []byte(code), os.ModePerm); err != nil {
		log.Fatal(err)
	}
	log.Printf("Generated '%s' from '%s'", outPath, url)
}

func genCode(hs holidays.Holidays, ut time.Time) string {
	sort.Slice(hs, func(i, j int) bool {
		return hs[i].Time.Before(hs[j].Time)
	})
	list := make([]string, 0)
	list2 := make([]string, 0)
	for _, h := range hs {
		code := fmt.Sprintf(
			codeBlockTmpl,
			h.Time.Year(), h.Time.Month(), h.Time.Day(),
			h.I18n[language.Japanese], h.I18n[language.English],
		)
		if strings.HasPrefix(h.I18n[language.Japanese], "振替休日") {
			list2 = append(list2, code)
		}
		list = append(list, code)
	}
	return fmt.Sprintf(tmpl,
		ut.Format("2006/01/02"),
		hs[0].Time.Format("2006/01/02"), hs[len(hs)-1].Time.Format("2006/01/02"),
		strings.TrimSpace(strings.Join(list, "\n\t")),
		strings.TrimSpace(strings.Join(list2, "\n\t")),
	)
}

// filePath creates a normalized file path.
func filePath(dir, file string) (string, error) {
	outDir, err := filepath.Abs(dir)
	if err != nil {
		return "", err
	}

	stat, err := os.Stat(outDir)
	if err != nil {
		return "", err
	}

	if !stat.IsDir() {
		return "", fmt.Errorf("%s is not a directory", outDir)
	}
	outDir = outDir + "/"
	return filepath.Join(outDir, file), nil
}
